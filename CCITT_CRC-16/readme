1.      巩固运算符的知识，完成CCITT CRC-16的CRC计算
即，实现如下函数，并采用它验算“\x12\x34\x56\x78”数据块的CRC值，应该为：0xB42C。
ushort get_crc16(const uchar *data_block,int data_len);
其中： data_block是欲被计算CRC的数据块的地址
       data_len是欲被计算CRC的数据块的字节数
返回值是算出的校验码。
 
CRC:Cyclic Redundancy Check, 循环冗余算法。因类似于采用除法求余数、但又有些不同，而得名。这个算法不关心商是多少，只关心冗余数（类似于余数）。
CRC附在原始数据尾部，就像盖一个较简单的印章一样，虽不能防止数据被专业人员篡改、却可以鉴别出数据被非专业人员篡改或被外界干扰、传输错误等破坏,CRC对突发错误的检测特别有效。
除数的选择一般与所应用的场合相适应，如CCITT CRC-16算法所选用的除数是0x11021, 适应于通讯信道。其适应性，是通过实验来验证的，并不是通过什么理论来确定的。
需采用如下CRC-16算法：
1）  将数据块看成是一个从左至右的二进制数据流，后补16位零;
2）  像除法一样对位放除数，只不过除法对位标准是被除数部分要大于除数，而CRC对位是找到被除数中的首个1即可开始放除数。
注意，除数是17位数。
3）  对位后，将除数和对好的被除数17位部分进行异或运算
4）  将异或运算的最左边零位元全部去掉，同时，从被除数后续位元中复制同样位元数的数据添加到其尾部，最终又形成一个17位的被除数。
5）  将该17位的被除数与除数进行异或运算。并跳转4，如此循环进行，直到剩下的被除数已小于17位为止。
6）  该小于17的余数，即最终的结果。把该余数用两字节来表达，把左字节看成是高8位、右字节看成低8位（即大尾码/big-endian format，这样来理解大尾码：把数据在内存的连续存取看成是一条龙在游动，它从低地址连续地向高地址方向游动，故龙尾指向低地址方向，若龙尾方向存放整数的高位字节，则这种存取整数的方式就是大尾方式；反之是小尾方式），存入一个整数，并输出。
从以上算法介绍来看，CRC运算与除法求余数极其相像。只不过除法运算的每步是减法，此外，对位标准有一点差异
